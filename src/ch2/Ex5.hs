module Ch2.Ex5 where

import Ch2.Data.BinTree
import Prelude

--  Совместное использование может быть полезно и внутри одного объекта, не
--  обязательно между двумя различными.  Например, если два поддерева
--  одного дерева идентичны, их можно представить одним и тем же
--  деревом.
--    Используя эту идею, напишите функцию complete типа
--    complete :: a -> Int -> BinTree a, такую, что
--    complete x, d создает полное двоичное дерево глубины
--    d, где в каждом узле содержится x.
--    (Разумеется, такая функция бессмысленна для абстракции множества,
--    но она может оказаться полезной для какой-либо другой абстракции,
--    например, мультимножества.) Функция должна работать за время O(d).
--
--    Расширьте свою функцию, чтобы она строила сбалансированные
--    деревья произвольного размера. Эти деревья не всегда будут полны,
--    но они должны быть как можно более сбалансированными: для любого
--    узла размеры поддеревьев должны различаться не более чем на
--    единицу. Функция должна работать за время O(log n). (Подсказка:
--    воспользуйтесь вспомогательной функцией,
--    которая, получая размер m, создает пару деревьев одно размера
--    m, а другое размера m + 1)

complete :: (Ord a) => a -> Int -> BinTree a
complete _ 0 = Empty
complete x d = Node n x n
  where n = complete x (d - 1)

completeBalanced :: (Ord a) => a -> Int -> BinTree a
completeBalanced _ 0 = Empty
completeBalanced x d = Node left x right
  where
    dl = (d - 1) `div` 2
    dr = d - dl - 1
    left = completeBalanced x dl
    right = if dr == dl then left else completeBalanced x dr